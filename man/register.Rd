% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/registration.R
\name{register}
\alias{register}
\title{Registration based on the NMI criteria}
\usage{
register(surf, targ, method = "gen", par0 = NULL, lower = NULL,
  upper = NULL, trans = FALSE, control = NULL)
}
\arguments{
\item{surf, targ}{cimg objects}

\item{method}{character indicating the method to be used}

\item{par0}{numeric vector for the initial guess for the registration parameters}

\item{lower, upper}{numeric vector for the bounds of the optimization problem}

\item{trans}{logical indicating if the relocated surface should
be returned instead of the registrated parameters}

\item{control}{list to control the parameters of the optimization routine}
}
\value{
bla bla
}
\description{
bla bla
}
\examples{
# simulated shif to check if the taylor approximation is correct
imA <- ground[[1]]
imB <- transform(imA, 0.5, -0.2, 0, method = 'taylor')
round(register(imB, imA, method = 'taylor'),2)
# see that the obtained value for the registration parameters are equal
# to the oposite applyed transformation values.
##
## The following examples were exluded from the automatic
## run to save compilation time. However, they should all be working.
# Now lets check the differences between the algorithms for a real image
\dontrun{
imB <- ground[[20]]
(par.taylor <- register(imB, imA, method = 'taylor'))
(par.grad   <- register(imB, imA, method = 'grad'))
(par.gen    <- register(imB, imA, method = 'gen'))
imB.grad <- transform(imB, par.grad[1], par.grad[2], par.grad[3])
imB.gen  <- transform(imB, par.gen[1], par.gen[2], par.gen[3])
NMI(imA,imB)
NMI(imA,imB.grad)
NMI(imA,imB.gen)
par(mfrow = c(1,2))
plot(rm.outliers(imA - imB.grad))
plot(rm.outliers(imA - imB.gen))
}
# Now, lets see if we can visualize the motion of the sample
\dontrun{
pars.taylor <- t(sapply(ground, register, targ = ground[[1]], method = 'taylor'))
pars.grad   <- t(sapply(ground, register, targ = ground[[1]], method = 'grad'))
pars.gen    <- t(sapply(ground, register, targ = ground[[1]], method = 'gen'))
plot(0, pch = NA, asp = 1,
 xlim = range(rbind(pars.taylor[,1], pars.grad[,1], pars.gen[,1])),
 ylim = range(rbind(pars.taylor[,2], pars.grad[,2], pars.gen[,2])))
points(pars.taylor[,1:2], col = 'orange')
points(pars.grad[,1:2], col = 'skyblue')
points(pars.gen[,1:2], col = 'black')
lines(pars.taylor[,1:2], col = 'orange')
lines(pars.grad[,1:2], col = 'skyblue')
lines(pars.gen[,1:2], col = 'black')
summary(pars.taylor[,3])
summary(pars.grad[,3])
summary(pars.gen[,3])
}
}
